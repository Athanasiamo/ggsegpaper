---
title: Visualisation of Brain Statistics with R-package `ggseg`
preprint: true
author: 
  - name: Athanasia M. Mowinckel
    affiliation: 1
    corresponding: true
    email: a.m.mowinckel@psykologi.uio.no
  - name: Didac Vidal PiÃ±eiro
    affiliation: 1
affiliation:
  - code: 1
    address: Center for Lifespan Changes in Brain and Cognition, Univeristy of Oslo, PO. box 1094 Blindern, 0317 Oslo, Norway
abstract: >
  The abstract of the article.
  It can also be on *multiple* lines.
header-includes: 
- \usepackage{lipsum} 
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
bibliography: sample.bib
output:
  bookdown::pdf_book:
    base_format: rticles::peerj_article # for using bookdown features like \@ref()
    fig_caption: true
  rticles::peerj_article: default
---
```{r setup, include=F}
knitr::opts_chunk$set(eval=TRUE, echo=TRUE)
library(kableExtra)
library(tidyverse)
library(plotly) 
library(ggplot2)
library(knitr)
options(tinytex.verbose = TRUE)

add_plotly <- function(plotly, file){
  orca(p, file = file, format = "png")
  knitr::include_graphics(file)
}

# Hook for setting latex text sizes
def.chunk.hook  <- knitr::knit_hooks$get("chunk") 
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

# Hook for setting code chunk wrapping
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})

dt <- data(package='ggseg')
dt <- as.data.frame(dt$results, stringsAsFactors = FALSE)

dtE <- data(package='ggsegExtra')
dtE <- as.data.frame(dtE$results, stringsAsFactors = FALSE)

dd <- bind_rows(dt, dtE) %>% 
  filter(!grepl("pal", Item)) %>% 
  mutate(Type = ifelse(grepl("3d", Item), "Mesh", "Polygon"),
         Item = gsub("_3d", "", Item),
         val = "Yes") %>% 
  select(Package, Title, Type, Item, val) %>% 
  spread(Type, val, fill = "No") %>% 
  mutate(Title = linebreak(stringr::str_wrap(Title, width = 40))) 

options(warnPartialMatchAttr = FALSE,
        warnPartialMatchDollar = FALSE,
        warnPartialMatchArgs = FALSE)
```

# Introduction

Neuroscientific analysis usually requires the use of multiple tools to analyse, visualise, and summarise data. 
This often makes the process of preparing results for publication laborious, as results must be exported and imported in various formats. 
In neuroimaging, images of probands' brains are collected and merged together to provide three dimensional representations.
Much of the neuroimaging analyses are not necessarily done on the individual voxel level (3-dimensional pixels), but rather on pre-defined brain segmentations, called brain atlases.
These brain atlases are plentiful and represent different ways of segmenting the brain into functionally or structurally similar regions (REF). 
The use of these is wide-spread, as these atlases provide larger meaningful divisions of the brain (REF). 
While neuroimaging analyses on the voxel-level are usually computed by special software for such analyses, analyses of brain atlas data is usually done in standard statistical software, like R (REF), python (REF), or Matlab (REF). 

A key part of understanding and disseminating analysis results, is the visualization of these in a meaningful way. 
With regards to results from brain atlas analyses, it is most meaningfully represented if projected onto a representation of the brain, rather than other common types of charts (like bar-charts) accompanied by a diagram of the brain label positions. 
Each atlas has its own labelling depending on what is meaningful for the type of segmentation it is based on. 
As such, for the reader to fully understand a bar chart with atlas labels, they need to be very familiar with the location of each label to have a clear comprehension of the results.
A projection directly onto a brain shape, eases the readability of the results for the reader, and provides clear point of reference even if the used atlas is unfamiliar. 

There are several tools that aid R-users in plotting neuroimaging data directly through R using the grammar of graphics as implemented in ggplot2 (REF), such as ggBrain(REF) and ggneuro(REF)(see [neuroconductor](https://neuroconductor.org/) for compiled neuroimaging packages for R). 
These are based on plotting imaging files, not results from analyses of brain atlases. 
Here we introduce the ggseg-package for visualizing results from brain atlas analyses.
The ggseg-package was developed to create templates that others might use to project their brain atlas results on to. 
While its plotting functions are what the users are drawn to, it is the pre-compiled number of data sets for different brain atlases that provides the real functionality needed for this visualization.
The package also includes functions to plot atlases in tri-surface mesh plots using plotly (REF). 

## Brain atlas selection
There is a multitude of brain atlases to chose from, all with different purposes and segmented based on different criteria. 
We have initially focused on commonly used and well-established atlases with manageable numbers of segmentations. 
The ggseg-package thus features data for two well-established parcellations, as implemented in the neuroimaging software Freesurfer (REF); dkt and aseg. 
The Desikan-Killany cortical atlas (dkt) (REF) and the Automatic Segmentation of Subcortical Structures (aseg) (REF) together cover all grey matter of the brain, and are commonly used in analyses elucidating the associations between thickness, volume, or area of these segments and mental health and cognitive function.

While functions and base data can be found in the main `ggseg`-package, a companion package called `ggsegExtra` has numerous other atlases, and is continuously expanded. 
We encourage the community to help build and expand the atlases available, and to create a repository of established and often used atlases. 
A summary of all available atlases may be found in Table \@ref(tab:atlasTab), where in addition to the two default atlases, ggsegExtra has another `r dd %>% filter(Package == "ggsegExtra") %>% nrow()` atlases.
The [ggseg wiki](https://github.com/LCBC-UiO/ggseg/wiki) currently has two different ways you may create and supply atlases to the package as 2D polygons.
Work is being done to include instructions on 3D-mesh plot contributions also. 
The package includes functions like `as_ggseg_atlas()` and `as_ggseg3d_atlas()` to aid users in testing and making custom atlases. 

```{r "atlasTab", echo=F, warning=FALSE, message=FALSE}
dd %>% 
  kable(format="latex", escape = FALSE, booktabs = TRUE,
               caption = "Table of currently available atlases in either ggseg or ggsegExtra R-package. Most atlases have both polygon and mesh atlases, but the mesh atlases are somewhat easier to create and are thus more plentiful. ") %>% 
  collapse_rows(1)
```

# Tutorial
This tutorial will introduce the `ggseg` and `ggsegExtra` packages and familiarize the reader with the main functions and the general use of the package. 
The tutorial will cover the following functions: `ggseg()` for plotting 2D polygons and `ggseg3d()` for plotting 3D brains based on tri-surface mesh plots.

## Plotting 2D polygon data with `ggseg` 

`ggseg` is the main function for plotting 2D data.  
By default, the function automatically plots the DKT atlas (see Figure \@ref(fig:init)). 
`ggseg` function is a wrapper for `geom_polygon` from `ggplot2` and it can be built upon and combined like any ggplot object. 
The image plot consists of a simple brain representation containing no extra information. 
Hence, `ggseg` plots can be easily complemented with any of the available ggplot features and options. 
We recommend users to get familiarized with [ggplot2](https://ggplot2.tidyverse.org/) grammar. 

```{r "init", fig.width=3, message=FALSE, fig.cap="By default `ggseg` will plot the dkt atlas in shaded polygons."}
library(ggseg)
library(tidyverse)
ggseg()
```

[comment]: <> (Figure 2 and 3 can be merged together. We can then use the figure legend to specify a little bit more. Not modified depending on your opinion)
`ggseg` is implemented as a fully-functional part of ggplot. 
Thus one should be able to use the function together with any other ggplot function such as themes or scales. 
See Figure \@ref(fig:void) for an example.

```{r void, fig.width=5, fig.cap="ggseg plots can be used together with most standard scales, themes and such that work with ggplot. The additional ggseg options for hemispheres, view etc. are atlas-specific. For example 'lateral' or 'medial' views are only available for cortical atlases such as the DKT. "}
p1 <- ggseg(position = "stacked") + 
  theme_dark() + 
  labs(title="dkt", subtitle = "dark theme")
p2 <- ggseg(position = "stacked") + 
  theme_classic() + 
  labs(title="dkt", subtitle = "classic theme")

# Combine plots
pp <- cowplot::plot_grid(p1, p2, nrow = 2)

p3 <- ggseg(atlas=aseg) + 
  labs(title="aseg", subtitle = "default theme")

# Create a subplot grid
cowplot::plot_grid(pp, p3, nrow = 1)
```

One has several options for plotting the main brain representations.
These options are atlas-specific. 
For cortical atlases, such as the DKT, one can stack the hemispheres, plot one or both hemisphere, or view only the medial or lateral side (or any combination of these; see Figure \@ref(fig:stacked)).
For subcortical atlases, such as the aseg, the options are more limited but one can often choose between axial, sagital, and coronal views.  

```{r stacked, fig.width=5, fig.cap="One can control the organization and the global visualization of a ggseg plot with gggseg-specific options such as hemisphere or view. Top left: plot using medial view. Bottom left: plot using left hemisphere. Right: plot combining both the options. "}
lat <- ggseg(view = "medial") + 
  labs(title = "Medial view")
left <- ggseg(hemisphere = "left") + 
  labs(title = "Left hemi.")
pp <- cowplot::plot_grid(lat, left, nrow=2)

combo <- ggseg(view = "medial",
      hemisphere = "left") + 
  labs(title = "Combination")

cowplot::plot_grid(pp, combo, nrow=1)
```


### Using own data with fill and colour
`ggseg` accepts any argument you can supply to `geom_polygon` and therefore is easy to work with for those familiar with ggplot functionality. 
Standard arguments like `fill` to flood the segments with a colour, or `colour` to colour the edges around the segments are typical arguments to provide to the function either as a single value or within the ggplot mapping option `aes`.
To use color palettes corresponding to those used in the original neuroimaging softwares one can use atlas-specific 'brain' palette scales. See an example in Figure \@ref(fig:fill).



```{r fill, fig.width=5, fig.height=8, fig.cap="Supplying 'area' to the fill option in ggseg, will use the column 'area' from the accompanying dataset to create a discrete colour palette over the segments in the atlas. The scale_fill_brain("dkt") option will colour the plot according the original colors used in FreeSurfer."}
ggseg(mapping=aes(fill = area), colour="black") + 
  scale_fill_brain("dkt") +
  theme(legend.justification=c(1,0),
        legend.position="bottom",
        legend.text = element_text(size = 5)) +
  guides(fill = guide_legend(ncol = 3))
```

[comment]: <> (Starting here I do not comment, as maybe re-structuring is better; waiting for input)
Most users will use ggseg to display through a color scale some descriptive or inferential statistics such as mean cortical thickness or thickness â cognition relationship across the different brain regions.
The bulk of the package originates not in its functions, but in the datasets that accompany the package. 
There is one dataset per atlas, which contains key information regarding the atlas, and coordinates for the segment polygons of the atlas. 
Before setting up the data from the statistics to project onto the segments, looking at the atlas datasets might help understand what the data needs to look like, or avoid looking like. 

```{r, fig.cap="All ggseg polygon atlases are required to have at minimum 6 columns with the names: 'long', 'lat', 'id', 'hemi', 'area', 'side'. These columns are necessary for the ggseg function to work. The additional columns in the dkt were added for various practical reasons.", size='small'}
dkt
```

[comment]: <> (End of no comments, as maybe re-structuring is better; waiting for input)
In any atlas, the column âlabelâ is particularly useful for combining the data of interest with the âggsegâ polygons. 
The column âlabelâ contains the label (region) names as in the original neuroimaging software. 
For example, the DKT atlas label column matches the region names from Freesurfer statistics tables.
Yet the data in âggsegâ is in a long format - that is each region has its own row - thus data of interest needs to be converted into this format. 
Note that most datasets are organized in wide format, in which subjects are represented by rows and each different data variable is represented in a separate column. 
See below an example of wide-to-long conversion. 

```{r}
freesurfer_stats <- data.frame(
  id = c(10:12),
  lh_superiortemporal = c(3.32, 4.1, 3.5),
  lh_precentral = c(2.3, 2.5, 2.1),
  lh_rostralmiddlefrontal = c(3.3, 3.2, 3.1)
  )
freesurfer_stats

freesurfer_long <- freesurfer_stats %>% 
  gather(label, thickness, -id)
freesurfer_long
```

This data - in long format - can now be used directly with the `ggseg` function, as the `label` column corresponds in name and content with the `label` column in the atlas data of dkt.
The data **must** include a column that has the same name at least _some_ data matching the values in the corresponding column in the atlas data.
In the next example we create some data with 4 rows, and an 'area' and 'p' column, representing the results of an analysis. 
The `ggseg` function will recognise the matching column 'area', and merge the supplied data into the atlas using `dplyr` joins. 
We use the `p` column as the column flooding the segment with colour.

```{r datasupp, fig.width=5}
someData = data.frame(
  area = c("transverse temporal", "insula",
           "pre central","superior parietal"), 
  p = sample(seq(0,.5,.001), 4),
  stringsAsFactors = FALSE)

p <- ggseg(.data=someData, mapping=aes(fill=p))
p
```

We can then modify the appearance similarly to any other ggplot graph using ggplot functions such as scales, labs, themes, etc. 
```{r datasupp2, fig.width=5}
p +
  theme_void() +
  scale_fill_gradient(low="firebrick",high="goldenrod") +
  labs(title="A nice plot title", fill="p-value")
```

If the results are only in one hemisphere, but you still want to plot both of them, make sure your data.fame includes the column `hemi` with either "right" or "left" for this to happen.
```{r datasuppX, fig.width=5}
someData$hemi = "right"

ggseg(.data=someData, colour="white",mapping=aes(fill=p)) +
  theme_void() +
  scale_fill_gradient(low="firebrick",high="goldenrod") +
  labs(title="Another nice plot title")
```

### Creating subplots
One can plot a statistic of interest in different groups (i.e. thickness or significance in young or older adults) using ggplot's `facet_wrap` or `facet_grid`.
As before, data needs to be in long format (group data should appear in seperate rows, not in separate columns). 
Secondly, the data needs to be grouped using `dplyr`'s `group_by` function _before_ providing the data to the `ggseg` function. 
The ggseg function will detect grouped data, and adapt it to `facet`'s requirements.

```{r datasupp3, fig.width=5}
someData = data.frame(
  area = rep(c("transverse temporal", "insula",
               "pre central","superior parietal"),2), 
  p = sample(seq(0,.5,.001), 8),
  AgeG = c(rep("Young",4), rep("Older",4)),
  stringsAsFactors = FALSE) %>% 
  group_by(AgeG)
  
ggseg(.data=someData, colour="white", mapping=aes(fill=p)) +
  facet_wrap(~AgeG, ncol=1) +
  theme(legend.position = "bottom")
```

As before, one can apply the different ggplot and facet options, such as `scales` to modify the plot's appearance.

```{r datasupp5, fig.width=5}
ggseg(.data = someData, atlas=dkt, 
      colour="white", position="stacked",
      mapping=aes(fill=p)) +
  facet_wrap(~AgeG, ncol=2) +
  theme_dark() +
  theme(legend.position = "bottom",
        axis.text = element_blank(),
        axis.title = element_blank()
        ) +
  scale_fill_gradient2(high="goldenrod",
                       low="firebrick",
                       na.value="transparent")
```

All the concepts described above also work with the `aseg` atlas for subcortical structures, except hemisphere and view arguments that do not apply in subcortical atlases such as aseg. 
Again, inspecting the atlas data directly will be of aid when preparing data to use with the atlas
```{r , size = 'small', out.width='90%'}
aseg
```

```{r atlases, fig.width=5, fig.cap="The first 10 rows of the `aseg` dataset, that has some specific differences from the dkt, like missing the option to not view both hemispheres, as the plot would be hard to understand that way."}
ggseg(atlas="aseg", mapping=aes(fill=area))
```


## Plotting 3D mesh data

Representing brains as 2D polygons is a good solution for fast, efficient and flexible plotting, based on ggplot (a powerful tool for visualization) and that can be easily combined with interactive apps such as in shiny.
Yet brains are intrinsically 3D and it can be challenging to recognize the location of a region. This problem exacerbates in atlases that represent subcortical features â after all, cortical surfaces are 2D â such as grey matter structures or white matter tracts. 
Hence, here we also provide the ggseg3D function to plot, view and print 3D atlases in R. 
ggseg3D is based on tri-surface mesh plots using plotly. 
The data structure is somewhat more complex than the 2D ggplot polygon version and includes additional options for brain inflation, glass brains, camera locations, etc.  
As ggseg3D is based on plotly, the resulting brain atlases are interactive, which guides interpretation, and is useful for public dissemination. 
We recommend users to familiarize with [plotly](https://plotly-book.cpsievert.me/). 

Out-of-the-box, `ggseg3d()` works without supplying any extra information, and plots the `dkt_3d` atlas in 'LCBC' surface.
The 'LCBC' surface is the white matter surface, inflated in 10 steps, to increase visibility within folds of the brain, while still maintining curvature to indicate where folds have been.
All `[...]_3d` atlases have a built in `colour` column for default colour plotting of the segments.


```{r ggseg3d_1_out, message=FALSE, echo=F, eval=TRUE, out.width='30%'}
p <- ggseg3d(surface = "white")  %>% 
  layout(title="\nggseg3d(surface='white')",
         font =  list(size = 30))
add_plotly(p, "png/ggseg3d_white.png")

p <- ggseg3d()  %>% 
  layout(title="\nggseg3d(surface='LCBC')",
         font =  list(size = 30))
add_plotly(p, "png/ggseg3d.png")

p <- ggseg3d(surface = "inflated") %>%
  layout(title="\nggseg3d(surface='inflated')",
         font =  list(size = 30))
add_plotly(p, "png/ggseg3d_inflated.png")
```

The cortical atlas data is stored in nested tibbles, which have datasets for three different surfaces and the two hemispheres.
The 'data'-column within includes all necessary information to `ggseg3d()` to create a mesh-plot. 
```{r, out.width='90%', size='small'}
dkt_3d
```

To grab all the data for a surface and hemisphere, you should reduce the data to one line, and then `unnest()`
```{r out.width='40%', linewidth=70}
dkt_3d %>% 
  filter(surf == "inflated" & hemi == "right") %>% 
  unnest(ggseg_3d) %>% 
  select(-lobe, -acronym)
```

### External data supply
Particularly notice the `mesh` column, which is a list column of lists. 
In there is all the 6 vectors needed to create the mesh of the tri-surface plot. 
You'll also need to notice the `label`, `annot` and `area` columns, which are likely the columns you will be matching on when proviging with your own data for colours. 
You need to be meticulous when fixing your data, be sure it matches.
The function _should_ give you a warning if it's struggling to match something. 

The column you want to use for colour, needs to be supplied to the `colour` option, and you'll likely want to supply it to the `text` option, as this will add another line to the plotly hover information.

```{r, eval=FALSE, out.width='40%'}
someData = dkt_3d %>% 
  filter(surf == "inflated" & 
         hemi == "right") %>% 
  unnest(ggseg_3d) %>% 
  select(area) %>% 
  na.omit() %>% 
  mutate(p = sample(seq(0,.5, length.out = 100 ), nrow(.)) %>% 
           round(2)) 
  
  ggseg3d(.data = someData, atlas = dkt_3d, colour = "p", text = "p")
```

```{r, out.width='40%', echo=FALSE}
someData = dkt_3d %>% 
  filter(surf == "inflated" & hemi == "right") %>% 
  unnest(ggseg_3d) %>% 
  select(area) %>% 
  na.omit() %>% 
  mutate(p = sample(seq(0,.5, length.out = 100 ), nrow(.)) %>% 
           round(2)) 

p <- ggseg3d(.data = someData, atlas = dkt_3d, 
             colour = "p", text = "p")
add_plotly(p, "png/ggseg3d_data.png")
```

### Colours

You can provide custom colour palettes either in hex or R-names.
Colours will be evenly spaced when creating the colour-scale, and you may provide as many colours as you wish.


```{r,fig.width=5, eval=FALSE, out.width='45%'}
  ggseg3d(.data = someData, atlas = dkt_3d, 
          colour = "p", text = "p", 
          palette = c("#ff0000", "#00ff00", "#0000ff"))
```
```{r, out.width='40%', echo=F, eval=T}
p <- ggseg3d(.data = someData, atlas = dkt_3d, 
          colour = "p", text = "p", 
          palette = c("#ff0000", "#00ff00", "#0000ff"))
add_plotly(p, "png/ggseg3d_colour.png")
```

If you want to alter the colour of `NA` regions, supply `na.colour`, either as HEX colour or colour name.
This option only takes a single colour.
```{r, out.width='40%', eval=FALSE,  out.width='45%'}
  ggseg3d(.data = someData, atlas = dkt_3d, 
          colour = "p", text = "p", 
          na.colour = "black", camera="medial")
```
```{r, out.width='40%', echo=F, eval=T}
p <-   ggseg3d(.data = someData, atlas = dkt_3d, 
          colour = "p", text = "p", 
          na.colour = "black", camera="medial")
add_plotly(p, "png/ggseg3d_nacolour.png")
```

If you are plotting the sub-cortical structures, you might want to reduce the opacity of the `NA` structures, so that you can see the more medial structures. 
You may also want to add the `glassbrain` option, any value above 0 and up to 1 increases the opacity of a glass brain overlay.
The glassbrain option provides a frame of reference for the subcortical structures, and as such it is recommended to add this when viewing these structures.
There are three glassbrain options, controlling the opacity, which hemispheres to add, and the colour.

```{r, out.width='40%', warning=F, message=FALSE, eval=FALSE}
somData_aseg = aseg_3d %>% 
  unnest() %>% 
  select(label) %>% 
  filter(!grepl("Ventricle|Putamen", label)) %>% 
  mutate(p = seq(1, nrow(.))) 

  ggseg3d(.data = somData_aseg, atlas = aseg_3d, 
          colour = "p", text = "p", 
          na.alpha= .5, glassbrain = .5, 
          glassbrain_hemisphere = "left")
```
```{r, out.width='40%', echo=F, eval=T}
somData_aseg = aseg_3d %>% 
  unnest() %>% 
  select(label) %>% 
  filter(!grepl("Ventricle|Putamen", label)) %>% 
  mutate(p = seq(1, nrow(.))) 

p <- ggseg3d(.data = somData_aseg, atlas = aseg_3d, 
          colour = "p", text = "p", 
          na.alpha= .5, glassbrain = .5, 
          glassbrain_hemisphere = "left")
add_plotly(p, "png/ggseg3d_glass.png")
```

There are many plotly options that may help you adapt the plot to look the way you wish. 
In addition to Carson Sievert's [book on plotly in R](https://plotly-book.cpsievert.me/), we recommend resources for [modifying axes in 3D plots](https://plot.ly/r/axes/#modifying-axes-for-3D-plots), the [basic introduction to tri-surface plots](https://plot.ly/r/trisurf/), and this tutorial on [tri-surface plots with plotly in R](https://moderndata.plot.ly/trisurf-plots-in-r-using-plotly/). 

# Summary
The aim of the `ggseg`-package is to aid researchers easily disseminate analysis results in an easier and more stream-lined fashion. 
This tutorial should provide instructions on how to use the main package functions, and cover the most commonly used options.
The two main functions in the package, `ggseg()` and `ggseg3d()`, create polygon and mesh-plots of brain atlases, using the accompanying package data.
In addition to the two default atlases available in `ggseg`, the `ggsegExtra` package includes `r dd %>% filter(Package == "ggsegExtra") %>% nrow()` more atlases.
We encourage users of this package to contribute more atlases they find uses for, and help build an extensive repository of brain atlases.

